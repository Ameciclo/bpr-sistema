#include <Arduino.h>
#include <WiFi.h>
#include <NimBLEDevice.h>
#include <ArduinoJson.h>
#include <LittleFS.h>

// Hardware pins
#define LED_PIN 8
#define BUTTON_PIN 9
#define BATTERY_PIN A0

// States
enum State { BOOT, CONFIG_REQUEST, SCANNING, AT_BASE, SLEEP };
State currentState = BOOT;

// BLE
NimBLEClient* pClient = nullptr;
bool bleConnected = false;

// WiFi buffer
struct WiFiRecord {
    uint32_t timestamp;
    uint8_t bssid[6];
    int8_t rssi;
};
WiFiRecord wifiBuffer[50];
int bufferCount = 0;

// Config
struct Config {
    // Basic
    char bike_id[32] = "";        // ID √∫nico gerado (bpr-1xaos912)
    char bike_name[32] = "";      // Nome dado pela base
    char base_ble_name[32] = "BPR Hub Station";
    int version = 1;
    bool dev_mode = true;
    
    // WiFi
    int scan_interval_sec = 300;
    int scan_interval_low_batt_sec = 900;
    int wifi_scan_timeout_ms = 5000;
    int wifi_max_networks = 20;
    int wifi_rssi_threshold = -90;
    
    // BLE
    int ble_scan_time_sec = 5;
    int ble_connection_timeout_ms = 10000;
    
    // Power
    int radio_coordination_delay_ms = 300;
    int light_sleep_duration_ms = 1000;
    int deep_sleep_sec = 3600;
    int max_time_without_base_sec = 7200;
    
    // Battery
    float battery_critical_voltage = 3.2;
    float min_battery_voltage = 3.45;
    float battery_full_voltage = 4.2;
    
    // Timing
    int status_report_interval_ms = 30000;
    int emergency_button_hold_ms = 3000;
    
    // Buffers
    int max_wifi_records = 100;
} config;

// Function declarations
void handleBoot();
void handleScanning();
void handleAtBase();
void handleSleep();
bool scanForBase();
bool connectToBase(NimBLEAdvertisedDevice* device);
void sendStatus();
void sendWiFiData();
float getBatteryVoltage();
void saveBuffer();
void loadBuffer();
bool loadConfig();
void saveConfig();
String getChipID();
void generateUniqueID();
void handleConfigRequest();
bool requestConfigFromBase();

void setup() {
    Serial.begin(115200);
    pinMode(LED_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    
    if (!LittleFS.begin(true)) {
        Serial.println("üîß LittleFS corrompido - formatando...");
        LittleFS.format();
        LittleFS.begin(true);
    }
    WiFi.mode(WIFI_STA);
    NimBLEDevice::init("BPR_Bici");
    
    Serial.println("üö≤ BPR Bici Simple v1.0");
    
    // Gerar ID √∫nico se n√£o existir
    generateUniqueID();
    
    // Load config first
    if (!loadConfig()) {
        Serial.println("‚öôÔ∏è No config found - entering CONFIG_REQUEST");
        currentState = CONFIG_REQUEST;
    } else {
        // Load saved buffer if exists
        loadBuffer();
        currentState = BOOT;
    }
}

void loop() {
    switch (currentState) {
        case BOOT:
            handleBoot();
            break;
        case CONFIG_REQUEST:
            handleConfigRequest();
            break;
        case SCANNING:
            handleScanning();
            break;
        case AT_BASE:
            handleAtBase();
            break;
        case SLEEP:
            handleSleep();
            break;
    }
    
    delay(100);
}

void handleBoot() {
    Serial.println("üîÑ BOOT");
    
    // Show current config
    Serial.println("üìã Current Configuration:");
    Serial.printf("   üÜî ID: %s (v%d)\n", config.bike_id, config.version);
    Serial.printf("   üì° WiFi Scan: %ds interval, %dms timeout\n", config.scan_interval_sec, config.wifi_scan_timeout_ms);
    Serial.printf("   üîµ BLE: %ds scan, base='%s'\n", config.ble_scan_time_sec, config.base_ble_name);
    Serial.printf("   üîã Battery: %.2fV critical, %.2fV low\n", config.battery_critical_voltage, config.min_battery_voltage);
    Serial.printf("   üõ†Ô∏è Dev Mode: %s\n", config.dev_mode ? "ON" : "OFF");
    
    // Check battery with debug
    int rawADC = analogRead(BATTERY_PIN);
    float voltage = getBatteryVoltage();
    
    Serial.printf("üîã Battery: ADC=%d, V=%.2fV (min=%.2fV)\n", 
                  rawADC, voltage, 3.2f);
    
    if (voltage < config.battery_critical_voltage && !config.dev_mode) {
        Serial.println("üîã Bateria cr√≠tica - sleep");
        Serial.println("üí° Tip: Check battery connection or use USB power for testing");
        currentState = SLEEP;
        return;
    } else if (voltage < config.battery_critical_voltage && config.dev_mode) {
        Serial.println("üõ†Ô∏è DEV MODE: Ignoring low battery");
    }
    
    // Try to find base
    if (scanForBase()) {
        currentState = AT_BASE;
    } else {
        currentState = SCANNING;
    }
}

void handleScanning() {
    static unsigned long lastScan = 0;
    
    if (millis() - lastScan > config.scan_interval_sec * 1000) {
        Serial.printf("üì° Starting WiFi scan (timeout: %dms, max: %d networks)...\n", 
                      config.wifi_scan_timeout_ms, config.wifi_max_networks);
        
        // WiFi scan
        int networks = WiFi.scanNetworks();
        for (int i = 0; i < networks && bufferCount < config.max_wifi_records; i++) {
            if (WiFi.RSSI(i) > config.wifi_rssi_threshold) {
                WiFiRecord record;
                record.timestamp = millis() / 1000;
                memcpy(record.bssid, WiFi.BSSID(i), 6);
                record.rssi = WiFi.RSSI(i);
                wifiBuffer[bufferCount++] = record;
            }
        }
        WiFi.scanDelete();
        
        Serial.printf("üì∂ Found %d networks, saved %d (buffer: %d/%d)\n", 
                      networks, bufferCount, bufferCount, config.max_wifi_records);
        
        // Radio coordination delay
        Serial.printf("‚è±Ô∏è Radio coordination delay: %dms\n", config.radio_coordination_delay_ms);
        delay(config.radio_coordination_delay_ms);
        if (scanForBase()) {
            currentState = AT_BASE;
            return;
        }
        
        lastScan = millis();
    }
    
    // Check battery
    if (getBatteryVoltage() < config.min_battery_voltage && !config.dev_mode) {
        currentState = SLEEP;
    }
}

void handleAtBase() {
    if (!bleConnected) {
        currentState = SCANNING;
        return;
    }
    
    Serial.println("üè† AT_BASE - Syncing data");
    
    // Send status
    sendStatus();
    
    // Send WiFi data if available
    if (bufferCount > 0) {
        sendWiFiData();
        bufferCount = 0; // Clear buffer
    }
    
    delay(5000);
    
    // Check connection
    if (pClient && !pClient->isConnected()) {
        bleConnected = false;
        currentState = SCANNING;
    }
}

void handleSleep() {
    Serial.println("üí§ Deep sleep for 1 hour");
    
    // Save buffer
    saveBuffer();
    
    // Deep sleep
    esp_sleep_enable_timer_wakeup(3600 * 1000000ULL); // 1 hour
    esp_deep_sleep_start();
}

bool scanForBase() {
    Serial.printf("üîç Scanning for BLE base '%s*' (timeout: %ds)...\n", 
                  config.base_ble_name, config.ble_scan_time_sec);
    NimBLEScan* pScan = NimBLEDevice::getScan();
    pScan->setActiveScan(true);
    NimBLEScanResults results = pScan->start(config.ble_scan_time_sec, false);
    
    for (int i = 0; i < results.getCount(); i++) {
        NimBLEAdvertisedDevice device = results.getDevice(i); // Remove pointer
        if (device.getName().find(config.base_ble_name) != std::string::npos) {
            Serial.printf("üîç Found base: %s\n", device.getName().c_str());
            
            if (connectToBase(&device)) { // Pass address
                pScan->clearResults();
                return true;
            }
        }
    }
    
    pScan->clearResults();
    Serial.println("‚ùå No BLE base found");
    return false;
}

bool connectToBase(NimBLEAdvertisedDevice* device) {
    pClient = NimBLEDevice::createClient();
    
    Serial.printf("üîó Attempting BLE connection (timeout: %dms)...\n", config.ble_connection_timeout_ms);
    if (pClient->connect(device)) {
        bleConnected = true;
        Serial.println("‚úÖ BLE connection established");
        
        // Always request config on first connection
        if (currentState == CONFIG_REQUEST) {
            Serial.println("üîÑ First connection - requesting config...");
            if (requestConfigFromBase()) {
                Serial.println("‚úÖ Configuration received!");
            } else {
                Serial.println("‚ö†Ô∏è Config request failed, using defaults");
            }
        }
        
        return true;
    }
    
    Serial.println("‚ùå BLE connection failed");
    return false;
}

void sendStatus() {
    if (!pClient || !bleConnected) return;
    
    DynamicJsonDocument doc(256);
    doc["bike_id"] = config.bike_id;
    doc["battery"] = getBatteryVoltage();
    doc["records"] = bufferCount;
    doc["timestamp"] = millis() / 1000;
    
    String json;
    serializeJson(doc, json);
    
    // Find and write to characteristic (simplified)
    Serial.printf("üì§ Status: %s\n", json.c_str());
}

void sendWiFiData() {
    if (!pClient || !bleConnected || bufferCount == 0) return;
    
    DynamicJsonDocument doc(2048);
    JsonArray scans = doc.createNestedArray("scans");
    
    for (int i = 0; i < bufferCount; i++) {
        JsonObject scan = scans.createNestedObject();
        scan["ts"] = wifiBuffer[i].timestamp;
        
        char bssid[18];
        sprintf(bssid, "%02X:%02X:%02X:%02X:%02X:%02X",
                wifiBuffer[i].bssid[0], wifiBuffer[i].bssid[1], wifiBuffer[i].bssid[2],
                wifiBuffer[i].bssid[3], wifiBuffer[i].bssid[4], wifiBuffer[i].bssid[5]);
        scan["bssid"] = bssid;
        scan["rssi"] = wifiBuffer[i].rssi;
    }
    
    String json;
    serializeJson(doc, json);
    
    Serial.printf("üì° WiFi data: %d records\n", bufferCount);
}

float getBatteryVoltage() {
    static unsigned long lastRead = 0;
    static float lastVoltage = 4.0;
    
    // S√≥ l√™ a cada 5 segundos para evitar spam
    if (millis() - lastRead < 5000) {
        return lastVoltage;
    }
    
    int adc = analogRead(BATTERY_PIN);
    lastRead = millis();
    
    // Para desenvolvimento: assume USB se ADC baixo
    if (adc < 1500) {
        if (lastVoltage != 4.0) { // S√≥ printa uma vez
            Serial.printf("‚ö†Ô∏è ADC=%d - USB power (4.0V)\n", adc);
        }
        lastVoltage = 4.0;
        return 4.0;
    }
    
    lastVoltage = (adc / 4095.0) * 3.3 * 2.0;
    return lastVoltage;
}

void saveBuffer() {
    File file = LittleFS.open("/buffer.dat", "w");
    if (file) {
        file.write((uint8_t*)&bufferCount, sizeof(bufferCount));
        file.write((uint8_t*)wifiBuffer, sizeof(WiFiRecord) * bufferCount);
        file.close();
        Serial.println("üíæ Buffer saved");
    }
}

void loadBuffer() {
    File file = LittleFS.open("/buffer.dat", "r");
    if (file) {
        file.read((uint8_t*)&bufferCount, sizeof(bufferCount));
        file.read((uint8_t*)wifiBuffer, sizeof(WiFiRecord) * bufferCount);
        file.close();
        LittleFS.remove("/buffer.dat");
        Serial.printf("üìÇ Buffer loaded: %d records\n", bufferCount);
    }
}

bool loadConfig() {
    Serial.println("üìÇ Loading config from LittleFS...");
    File file = LittleFS.open("/config.json", "r");
    if (!file) {
        Serial.println("‚ùå Config file not found");
        return false;
    }
    
    DynamicJsonDocument doc(2048);
    DeserializationError error = deserializeJson(doc, file);
    file.close();
    
    if (error) {
        Serial.printf("‚ùå JSON parse error: %s\n", error.c_str());
        return false;
    }
    
    // Basic
    strcpy(config.bike_id, doc["bike_id"] | "bici_001");
    config.version = doc["version"] | 1;
    config.dev_mode = doc["dev_mode"] | true;
    
    // WiFi
    JsonObject wifi = doc["wifi"];
    config.scan_interval_sec = wifi["scan_interval_sec"] | 300;
    config.scan_interval_low_batt_sec = wifi["scan_interval_low_batt_sec"] | 900;
    config.wifi_scan_timeout_ms = wifi["scan_timeout_ms"] | 5000;
    config.wifi_max_networks = wifi["max_networks"] | 20;
    config.wifi_rssi_threshold = wifi["rssi_threshold"] | -90;
    
    // BLE
    JsonObject ble = doc["ble"];
    strcpy(config.base_ble_name, ble["base_name"] | "BPR");
    config.ble_scan_time_sec = ble["scan_time_sec"] | 5;
    config.ble_connection_timeout_ms = ble["connection_timeout_ms"] | 10000;
    
    // Power
    JsonObject power = doc["power"];
    config.radio_coordination_delay_ms = power["radio_coordination_delay_ms"] | 300;
    config.light_sleep_duration_ms = power["light_sleep_duration_ms"] | 1000;
    config.deep_sleep_sec = power["deep_sleep_duration_sec"] | 3600;
    config.max_time_without_base_sec = power["max_time_without_base_sec"] | 7200;
    
    // Battery
    JsonObject battery = doc["battery"];
    config.battery_critical_voltage = battery["critical_voltage"] | 3.2;
    config.min_battery_voltage = battery["low_voltage"] | 3.45;
    config.battery_full_voltage = battery["full_voltage"] | 4.2;
    
    // Timing
    JsonObject timing = doc["timing"];
    config.status_report_interval_ms = timing["status_report_interval_ms"] | 30000;
    config.emergency_button_hold_ms = timing["emergency_button_hold_ms"] | 3000;
    
    // Buffers
    JsonObject buffers = doc["buffers"];
    config.max_wifi_records = buffers["max_wifi_records"] | 100;
    
    Serial.printf("‚úÖ Config loaded: %s v%d\n", config.bike_id, config.version);
    Serial.printf("üì° WiFi: %ds interval, %dms timeout, %d networks max\n", 
                  config.scan_interval_sec, config.wifi_scan_timeout_ms, config.wifi_max_networks);
    Serial.printf("üîµ BLE: %ds scan, %dms timeout, base='%s'\n", 
                  config.ble_scan_time_sec, config.ble_connection_timeout_ms, config.base_ble_name);
    Serial.printf("üîã Battery: %.2fV critical, %.2fV low, %.2fV full\n", 
                  config.battery_critical_voltage, config.min_battery_voltage, config.battery_full_voltage);
    Serial.printf("‚ö° Power: %dms coord delay, %ds deep sleep\n", 
                  config.radio_coordination_delay_ms, config.deep_sleep_sec);
    
    return true;
}

void saveConfig() {
    Serial.println("üíæ Saving config to LittleFS...");
    DynamicJsonDocument doc(2048);
    
    // Basic
    doc["bike_id"] = config.bike_id;
    doc["version"] = config.version;
    doc["dev_mode"] = config.dev_mode;
    
    // WiFi
    JsonObject wifi = doc.createNestedObject("wifi");
    wifi["scan_interval_sec"] = config.scan_interval_sec;
    wifi["scan_interval_low_batt_sec"] = config.scan_interval_low_batt_sec;
    wifi["scan_timeout_ms"] = config.wifi_scan_timeout_ms;
    wifi["max_networks"] = config.wifi_max_networks;
    wifi["rssi_threshold"] = config.wifi_rssi_threshold;
    
    // BLE
    JsonObject ble = doc.createNestedObject("ble");
    ble["base_name"] = config.base_ble_name;
    ble["scan_time_sec"] = config.ble_scan_time_sec;
    ble["connection_timeout_ms"] = config.ble_connection_timeout_ms;
    
    // Power
    JsonObject power = doc.createNestedObject("power");
    power["radio_coordination_delay_ms"] = config.radio_coordination_delay_ms;
    power["light_sleep_duration_ms"] = config.light_sleep_duration_ms;
    power["deep_sleep_duration_sec"] = config.deep_sleep_sec;
    power["max_time_without_base_sec"] = config.max_time_without_base_sec;
    
    // Battery
    JsonObject battery = doc.createNestedObject("battery");
    battery["critical_voltage"] = config.battery_critical_voltage;
    battery["low_voltage"] = config.min_battery_voltage;
    battery["full_voltage"] = config.battery_full_voltage;
    
    // Timing
    JsonObject timing = doc.createNestedObject("timing");
    timing["status_report_interval_ms"] = config.status_report_interval_ms;
    timing["emergency_button_hold_ms"] = config.emergency_button_hold_ms;
    
    // Buffers
    JsonObject buffers = doc.createNestedObject("buffers");
    buffers["max_wifi_records"] = config.max_wifi_records;
    
    doc["timestamp"] = millis() / 1000;
    
    File file = LittleFS.open("/config.json", "w");
    if (file) {
        serializeJson(doc, file);
        file.close();
        Serial.println("‚úÖ Config saved successfully");
    } else {
        Serial.println("‚ùå Failed to save config");
    }
}

bool requestConfigFromBase() {
    if (!pClient || !bleConnected) {
        Serial.println("‚ùå No BLE connection to request config");
        return false;
    }
    
    Serial.println("üì° Requesting configuration from base...");
    
    // Find config characteristic
    NimBLERemoteService* pService = pClient->getService("12345678-1234-1234-1234-123456789abc");
    if (!pService) {
        Serial.println("‚ùå Service not found");
        return false;
    }
    
    NimBLERemoteCharacteristic* pConfigChar = pService->getCharacteristic("11111111-2222-3333-4444-555555555555");
    if (!pConfigChar) {
        Serial.println("‚ùå Config characteristic not found");
        return false;
    }
    
    // Send config request
    DynamicJsonDocument request(256);
    request["type"] = "config_request";
    request["bike_id"] = config.bike_id;
    
    String requestStr;
    serializeJson(request, requestStr);
    
    Serial.printf("üì§ Config request: %s\n", requestStr.c_str());
    pConfigChar->writeValue(requestStr.c_str());
    
    // Wait for response
    delay(2000);
    std::string response = pConfigChar->readValue();
    
    if (response.length() > 0) {
        Serial.printf("üì• Config response: %s\n", response.c_str());
        
        DynamicJsonDocument doc(1024);
        if (deserializeJson(doc, response) == DeserializationError::Ok) {
            if (doc["error"]) {
                Serial.printf("‚ùå Config error: %s\n", doc["error"].as<String>().c_str());
                return false;
            }
            
            // Update config from response
            if (doc["bike_name"]) strcpy(config.bike_name, doc["bike_name"]);
            if (doc["version"]) config.version = doc["version"];
            if (doc["dev_mode"]) config.dev_mode = doc["dev_mode"];
            
            if (doc["wifi"]["scan_interval_sec"]) {
                config.scan_interval_sec = doc["wifi"]["scan_interval_sec"];
            }
            if (doc["wifi"]["scan_timeout_ms"]) {
                config.wifi_scan_timeout_ms = doc["wifi"]["scan_timeout_ms"];
            }
            
            if (doc["ble"]["base_name"]) {
                strcpy(config.base_ble_name, doc["ble"]["base_name"]);
            }
            if (doc["ble"]["scan_time_sec"]) {
                config.ble_scan_time_sec = doc["ble"]["scan_time_sec"];
            }
            
            if (doc["power"]["deep_sleep_duration_sec"]) {
                config.deep_sleep_sec = doc["power"]["deep_sleep_duration_sec"];
            }
            
            if (doc["battery"]["critical_voltage"]) {
                config.battery_critical_voltage = doc["battery"]["critical_voltage"];
            }
            if (doc["battery"]["low_voltage"]) {
                config.min_battery_voltage = doc["battery"]["low_voltage"];
            }
            
            // Send confirmation
            DynamicJsonDocument confirm(128);
            confirm["type"] = "config_received";
            confirm["bike_id"] = config.bike_id;
            confirm["status"] = "ok";
            
            String confirmStr;
            serializeJson(confirm, confirmStr);
            pConfigChar->writeValue(confirmStr.c_str());
            
            Serial.printf("‚úÖ Config updated: %s v%d\n", config.bike_name, config.version);
            saveConfig();
            return true;
        }
    }
    
    Serial.println("‚ùå No config response received");
    return false;
}

void handleConfigRequest() {
    static unsigned long lastScan = 0;
    
    Serial.println("üîç CONFIG REQUEST - Searching for BLE base to get configuration...");
    
    // Procura base a cada 5 segundos
    if (millis() - lastScan > 5000) {
        if (scanForBase()) {
            Serial.println("‚úÖ Base found! Requesting configuration...");
            if (requestConfigFromBase()) {
                Serial.println("‚úÖ Configuration received and saved!");
                currentState = BOOT;
                return;
            } else {
                Serial.println("‚ùå Failed to get configuration from base");
            }
        }
        lastScan = millis();
    }
    
    // Fallback: bot√£o para usar configura√ß√£o padr√£o
    if (digitalRead(BUTTON_PIN) == LOW) {
        delay(100);
        if (digitalRead(BUTTON_PIN) == LOW) {
            Serial.println("üîß Using default configuration (button pressed)");
            saveConfig();
            currentState = BOOT;
        }
    }
    
    delay(1000);
}

void generateUniqueID() {
    if (strlen(config.bike_id) == 0) {
        String chipId = getChipID();
        snprintf(config.bike_id, sizeof(config.bike_id), "bpr-%s", chipId.c_str());
        Serial.printf("üÜî Generated unique ID: %s\n", config.bike_id);
        saveConfig();
    } else {
        Serial.printf("üÜî Using existing ID: %s\n", config.bike_id);
    }
}

String getChipID() {
    uint64_t chipid = ESP.getEfuseMac();
    char chipStr[9];
    snprintf(chipStr, sizeof(chipStr), "%08x", (uint32_t)(chipid & 0xFFFFFFFF));
    return String(chipStr).substring(0, 6); // Primeiros 6 caracteres
}